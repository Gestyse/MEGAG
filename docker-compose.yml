# docker-compose.yml
services:
  postgres-db: # O novo nome do serviço para o banco de dados
    image: postgres:16-alpine # Uma imagem oficial e leve do PostgreSQL, compatível com ARM64
    ports:
      - "5432:5432" # Porta padrão do PostgreSQL (Host:Contêiner)
    environment:
      POSTGRES_DB: megag_db # Nome do banco de dados que será criado
      POSTGRES_USER: app_user # Usuário para a aplicação
      POSTGRES_PASSWORD: your_postgres_password_here # <-- MUDE ISTO! Senha para o usuário da aplicação
    volumes:
      - postgres_data:/var/lib/postgresql/data # Volume persistente para os dados do DB
      - ./db_init:/docker-entrypoint-initdb.d 
    healthcheck: # Healthcheck para garantir que o DB está pronto
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 30s
    restart: unless-stopped

  python-app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "5001:5000" # Mapeamento de portas para acessar a aplicação
    environment:
      # Variáveis de ambiente para a aplicação Python se conectar ao PostgreSQL
      POSTGRES_USER: app_user
      POSTGRES_PASSWORD: your_postgres_password_here # Use a mesma senha definida para o DB
      POSTGRES_HOST: postgres-db # O nome do serviço Docker do banco de dados
      POSTGRES_PORT: 5432
      POSTGRES_DB: megag_db
      FLASK_APP: app.py
      FLASK_ENV: development
      FLASK_SECRET_KEY: 'sua_chave_secreta_muito_longa_e_aleatoria_para_o_flask' # <-- MUDE ISTO!
    volumes:
      - .:/app # Monta a pasta do seu projeto local no contêiner para desenvolvimento
    depends_on:
      postgres-db:
        condition: service_healthy # Garante que o DB esteja saudável antes de iniciar a aplicação
    restart: unless-stopped

volumes:
  postgres_data: # Define o volume nomeado para a persistência dos dados do PostgreSQL